{% extends "base_implementation.j2" %}

{% macro exit_function(state) %}
  {%- if "exit" in statemachine.states[state].functions -%}
smf__log_state_function("Calling state [{{ state }}] exit function smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions["exit"] }}");
smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions["exit"] }}(&(instance->instance_data));
  {%- endif -%} 
{% endmacro %}

{% macro entry_function(state) %}
  {%- if "entry" in statemachine.states[state].functions -%}
smf__log_state_function("Calling state [{{ state }}] entry function smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions["entry"] }}");
smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions["entry"] }}(&(instance->instance_data));
  {% endif %} 
{% endmacro %}


{% macro transition_function(state, event) %}
    {%if statemachine.states[state].transitions[event].function is not none %}
smf__log_state_function("Calling state [{{ state }}]({{ event }}) transition function smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].transitions[event].function }}");
smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].transitions[event].function }}(&(instance->instance_data), (smf_{{ statemachine.name|lower }}_event_{{ event|lower }}_t*)&(event->event_data.{{ event|lower }}));
    {% endif %}
{% endmacro %}


{% macro auto_transition_function(state) %}
    {%if statemachine.states[state].transitions["automatic"].function is not none %}
smf__log_state_function("Calling state [{{ state }}] automatic transition function smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].transitions["automatic"].function }}");
smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].transitions["automatic"].function }}(&(instance->instance_data));
    {% endif %}
{% endmacro %}

{% macro write_event_dispatch_state_block(event) %}
            switch (instance->current_state[0]) {
                {% for state in statemachine.events[event].affected_states if state in statemachine.states %}
                case SMF_STATE_{{ statemachine.name|upper }}_{{ state|replace(".","_")|upper }}:
                    {% if event in statemachine.states[state].functions %}
                        smf__log_event("Calling internal eventfunction smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions[event] }} from state [{{ state }}]");
                        smf_{{ statemachine.name|lower }}_{{ statemachine.states[state].functions[event] }}(&(instance->instance_data),(smf_{{ statemachine.name|lower }}_event_{{ event|lower }}_t*)&(event->event_data.{{ event|lower }}));
                    {% elif event in statemachine.states[state].transitions %}
                        smf__log_transition("Event ({{ event }}) caused transition from state [{{ state }}] to state [{{ statemachine.states[state].transitions[event].toState }}]");
                        {{ exit_function(state) }}
                        {{ transition_function(state, event) }}
                        instance->current_state[0] = SMF_STATE_{{ statemachine.name|upper }}_{{ statemachine.states[state].transitions[event].toState|replace(".","_")|upper }};
                        {{ entry_function(statemachine.states[state].transitions[event].toState) }}
                        *autotransition_pending = {{ statemachine.states[statemachine.states[state].transitions[event].toState].hasAutoTransition|lower }};
                    {% else %}
                        bool subevent_consumed = false;
                        bool subautotransition_pending = false;
                        {% for submachine in statemachine.states[state].statemachines %}
                            smf_{{ submachine|lower }}_process( &(instance->{{ submachine|lower }}), (smf_{{ submachine|lower }}_event_t*)event, &subevent_consumed, &subautotransition_pending );
                            if (subevent_consumed) *event_consumed=true;
                            if (subautotransition_pending) *autotransition_pending=true;
                        {% endfor %}
                    {% endif %}
                        *event_consumed = true;
                    break;
                {% endfor %}
                default:
                    break;
            }
{% endmacro %}


{% macro make_event_dispatch() %}
void smf_{{ statemachine.name|lower }}__event_dispatch(smf_{{ statemachine.name|lower }}__private_t* instance, smf_{{ statemachine.name|lower }}_event_t* event, bool* event_consumed, bool* autotransition_pending) {
    switch (event->id) {
        {% for event in statemachine.events %}
        case SMF_EVENT_{{ statemachine.name|upper }}_{{ event|upper }}:
{{ write_event_dispatch_state_block(event) }}
            break;
        {% endfor %}
        default:
            break;
    }
}
{% endmacro %}

{% macro do_auto_transitions() %}
void smf_{{ statemachine.name|lower }}__do_automatic_transition(smf_{{ statemachine.name|lower }}__private_t* instance, bool* autotransition_pending) {
    switch (instance->current_state[0]) {
        {% for state in statemachine.states if statemachine.states[state].hasAutoTransition %}
        case SMF_STATE_{{ statemachine.name|upper }}_{{ state|replace(".","_")|upper }}:
            smf__log_transition("Automatic transition from state [{{ state }}] to state [{{ statemachine.states[state].transitions["automatic"].toState }}]");
            {{ exit_function(state) }}
            {{ auto_transition_function(state) }}
            instance->current_state[0] = SMF_STATE_{{ statemachine.name|upper }}_{{ statemachine.states[state].transitions["automatic"].toState|replace(".","_")|upper }};
            {{ entry_function(statemachine.states[state].transitions["automatic"].toState) }}            
            *autotransition_pending = {{ statemachine.states[statemachine.states[state].transitions["automatic"].toState].hasAutoTransition|lower }}; 
            break;
        {% endfor %}
        default:
            break;
    }
}
{% endmacro %}

{% block include_section %}
#include <stdbool.h>
#include "smf_logging.h"
#include "smf_{{ statemachine.name|lower }}_types.h"
#include "smf_{{ statemachine.name|lower }}_functions.h"
#include "smf_{{ statemachine.name|lower }}.h"
{% for state in statemachine.states %}
    {% for submachine in statemachine.states[state].statemachines %}
#include "smf_{{ submachine|lower }}.h"
#include "smf_{{ submachine|lower }}_types.h"
    {% endfor %}
{% endfor %}
{% endblock include_section %}


{% block functions %}
{{ make_event_dispatch() }}
{{ do_auto_transitions() }}

smf_return_t smf_{{ statemachine.name|lower }}_process(smf_{{ statemachine.name|lower }}__private_t* instance, smf_{{ statemachine.name|lower }}_event_t* event, bool* event_consumed, bool* autotransition_pending )
{
    *event_consumed = false;
    *autotransition_pending = false;
    if (event == NULL) {
        smf_{{ statemachine.name|lower }}__do_automatic_transition(instance, autotransition_pending);
    } else {
        smf_{{ statemachine.name|lower }}__event_dispatch(instance, event, event_consumed, autotransition_pending);
    }
}

smf_return_t smf_{{ statemachine.name|lower }}_process_until_next_event(smf_{{ statemachine.name|lower }}__private_t* instance, smf_{{ statemachine.name|lower }}_event_t* event, bool* event_consumed)
{
    *event_consumed = false;
    smf_{{ statemachine.name|lower }}_event_t* _event = event;
    bool autotransition_pending = false;
    do {
        smf_{{ statemachine.name|lower }}_process(instance, _event, event_consumed, &autotransition_pending);
        _event = NULL;
    } while (autotransition_pending == true);
}

smf_return_t smf_{{ statemachine.name|lower }}_start(smf_{{ statemachine.name|lower }}__private_t* instance)
{
    instance->current_state[0] = SMF_STATE_{{ statemachine.name|upper }}_START;
    instance->current_active_states = 1;
    bool event_consumed = false;
    smf_{{ statemachine.name|lower }}_process_until_next_event(instance, NULL, &event_consumed);
}

smf_return_t smf_{{ statemachine.name|lower }}_get_state(smf_{{ statemachine.name|lower }}__private_t* instance, uint8_t* current_active_states, smf_{{ statemachine.name|lower }}_states_t** states)
{
    *current_active_states = instance->current_active_states;
    *states = instance->current_state;
}

{% endblock functions  %}